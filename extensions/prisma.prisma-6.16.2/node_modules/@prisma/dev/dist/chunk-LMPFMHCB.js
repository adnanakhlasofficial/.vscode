import{checkPort as w,getPort as m,isUnsafePort as O}from"get-port-please";import{difference as T,range as $}from"remeda";var v=51214,h=51213,S=51215,p=65535,P=-1/0;async function E(s){let{debug:t,name:e,requestedPorts:n,servers:u}=s,{portsUsedByOtherServers:r,portsUsedByThisServerLastTime:a}=x(e,u);t&&(console.debug(`ports used by other servers: ${Object.keys(r).join(", ")}`),console.debug(`ports used by "${e}" server last time: ${JSON.stringify(a)}`));let i={databasePort:P,port:P,shadowDatabasePort:P},o=["port","databasePort","shadowDatabasePort"];for(let c of o){let d=await k({debug:t,portKey:c,portsUsedByOtherServers:r,portsUsedByThisServerLastTime:a,requestedPorts:n})??await U({debug:t,pickedPorts:i,portKey:c,portsUsedByOtherServers:r,portsUsedByThisServerLastTime:a});t&&console.debug(`Got port for "${c}": ${d}`),i[c]=d}return t&&console.debug(`Picked ports: ${JSON.stringify(i)}`),i}async function k(s){let{debug:t,portKey:e,portsUsedByOtherServers:n,portsUsedByThisServerLastTime:u,requestedPorts:r}=s,{[e]:a,...i}=r;if(g(a))return await B({debug:t,otherRequestedPorts:i,portKey:e,portsUsedByOtherServers:n,requestedPort:a}),a;let o=u?.[e]??P;if(!g(o))return t&&console.debug(`No port specified for "${e}". Trying to pick a new port.`),null;let c=o in n;return c||Object.values(i).includes(o)?(t&&console.debug(`Port ${o} that was used last time for this server, ${c?"is also used by another server":"has been requested for another service"}. Trying to pick a new port.`),null):await w(o)===!1?(t&&console.debug(`Port ${o}, that was used last time for this server, is not available. Trying to pick a new port.`),null):(t&&console.debug(`Using port ${o} for "${e}" as it was used last time and is available.`),o)}async function U(s){let{debug:t,pickedPorts:e,portKey:n,portsUsedByOtherServers:u,portsUsedByThisServerLastTime:r}=s,a=Math.max(v,h,S)+1,i=[...Object.values(e),...Object.keys(u).map(Number),...Object.values(r||{})],o=Math.min(Math.max(a,...i)+100,p),c=T($(a,o),i),d={port:h,databasePort:v,shadowDatabasePort:S}[n];try{return await m({port:d in u||Object.values(e).includes(d)||Object.values(r||{}).includes(d)?void 0:d,ports:c})}catch(b){if(b instanceof Error&&b.name==="GetPortError"&&o+1<=p)return t&&console.debug(`Expanding port lookup to range [${o+1}, ${p}].`),await m({portRange:[o+1,p]});throw b}}function g(s){return s>=0}function x(s,t){let e={},n;for(let u of t){let{databasePort:r,port:a,shadowDatabasePort:i}=u;if(u.name===s){n={databasePort:r,port:a,shadowDatabasePort:i};continue}e[r]=!0,e[a]=!0,e[i]=!0}return{portsUsedByOtherServers:e,portsUsedByThisServerLastTime:n}}async function B(s){let{debug:t,otherRequestedPorts:e,portKey:n,portsUsedByOtherServers:u,requestedPort:r}=s;if(r in u)throw t&&console.error(`Port ${r} was requested for "${n}", but is already used by another server.`),new y(r);if(Object.values(e).includes(r))throw t&&console.error(`Port ${r} was requested for "${n}", but also for another key.`),new l(r);if(O(r))throw t&&console.error(`Port ${r} was requested for "${n}", but is unsafe.`),new f(r);if(await w(r)===!1)throw t&&console.error(`Port ${r} was requested for "${n}", but is not available.`),new f(r)}var f=class extends Error{constructor(e){super(`Port \`${e}\` is not available.`);this.port=e}name="PortNotAvailableError"},l=class extends Error{constructor(e){super(`Port number \`${e}\` was requested twice. Please choose a different port for each service.`);this.port=e}name="PortRequestedTwiceError"},y=class extends Error{constructor(e){super(`Port number \`${e}\` belongs to another Prisma Dev server. Please choose a different port.`);this.port=e}name="PortBelongsToAnotherServerError"};export{v as a,h as b,S as c,P as d,E as e,f};
