"use strict";var G=Object.create;var g=Object.defineProperty;var N=Object.getOwnPropertyDescriptor;var C=Object.getOwnPropertyNames;var M=Object.getPrototypeOf,q=Object.prototype.hasOwnProperty;var F=(e,t)=>{for(var r in t)g(e,r,{get:t[r],enumerable:!0})},O=(e,t,r,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of C(t))!q.call(e,a)&&a!==r&&g(e,a,{get:()=>t[a],enumerable:!(s=N(t,a))||s.enumerable});return e};var u=(e,t,r)=>(r=e!=null?G(M(e)):{},O(t||!e||!e.__esModule?g(r,"default",{value:e,enumerable:!0}):r,e)),I=e=>O(g({},"__esModule",{value:!0}),e);var Y={};F(Y,{dumpDB:()=>j,startDBServer:()=>z});module.exports=I(Y);var k=require("pathe/utils");var y=require("fs"),m=require("fs/promises"),T=require("util"),x=require("zlib");var o=u(require("path"),1),v=u(require("os"),1),b=u(require("process"),1),l=v.default.homedir(),S=v.default.tmpdir(),{env:f}=b.default,K=e=>{let t=o.default.join(l,"Library");return{data:o.default.join(t,"Application Support",e),config:o.default.join(t,"Preferences",e),cache:o.default.join(t,"Caches",e),log:o.default.join(t,"Logs",e),temp:o.default.join(S,e)}},H=e=>{let t=f.APPDATA||o.default.join(l,"AppData","Roaming"),r=f.LOCALAPPDATA||o.default.join(l,"AppData","Local");return{data:o.default.join(r,e,"Data"),config:o.default.join(t,e,"Config"),cache:o.default.join(r,e,"Cache"),log:o.default.join(r,e,"Log"),temp:o.default.join(S,e)}},W=e=>{let t=o.default.basename(l);return{data:o.default.join(f.XDG_DATA_HOME||o.default.join(l,".local","share"),e),config:o.default.join(f.XDG_CONFIG_HOME||o.default.join(l,".config"),e),cache:o.default.join(f.XDG_CACHE_HOME||o.default.join(l,".cache"),e),log:o.default.join(f.XDG_STATE_HOME||o.default.join(l,".local","state"),e),temp:o.default.join(S,t,e)}};function D(e,{suffix:t="nodejs"}={}){if(typeof e!="string")throw new TypeError(`Expected a string, got ${typeof e}`);return t&&(e+=`-${t}`),b.default.platform==="darwin"?K(e):b.default.platform==="win32"?H(e):W(e)}var V=u(require("zeptomatch"),1),oe=D("prisma-dev"),ne=(0,T.promisify)(x.unzip);async function A(e,t){await e.stream().pipeTo(y.WriteStream.toWeb((0,y.createWriteStream)(t,{encoding:"utf-8"})))}var $=require("get-port-please"),_=require("remeda");var h=class extends Error{constructor(r){super(`Port \`${r}\` is not available.`);this.port=r}name="PortNotAvailableError"};var i={connectionLimit:1,connectTimeout:0,database:"template1",maxIdleConnectionLifetime:0,password:"postgres",poolTimeout:0,socketTimeout:0,sslMode:"disable",username:"postgres"},X=`postgres://${i.username}:${i.password}@localhost`,R=new URLSearchParams({sslmode:i.sslMode}),J=new URLSearchParams({...Object.fromEntries(R.entries()),connection_limit:String(i.connectionLimit),connect_timeout:String(i.connectTimeout),max_idle_connection_lifetime:String(i.maxIdleConnectionLifetime),pool_timeout:String(i.poolTimeout),single_use_connections:"true",socket_timeout:String(i.socketTimeout)});async function z(e,t){let r=e==="database"?t.databasePort:t.shadowDatabasePort;if(t.dryRun)return E(e,t,{db:null,port:r,server:null});let{debug:s}=t,d=await(e==="shadow_database"?Q:L)(t.pgliteDataDirPath,s);s&&d.onNotification((n,p)=>{console.debug(`[${e}][${n}] ${p}`)});let{PGLiteSocketServer:P}=await import("@electric-sql/pglite-socket"),c=new P({db:d,debug:s,inspect:s,port:r});s&&(c.addEventListener("listening",n=>{let{detail:p}=n;console.debug(`[${e}] server listening on ${JSON.stringify(p)}`)}),c.addEventListener("connection",n=>{let{clientAddress:p,clientPort:U}=n.detail;console.debug(`[${e}] client connected from ${p}:${U}`)}),c.addEventListener("error",n=>{let{detail:p}=n;console.error(`[${e}] server error:`,p)}));try{await c.start()}catch(n){throw n instanceof Error&&"code"in n&&n.code==="EADDRINUSE"?new h(r):n}return E(e,t,{db:d,port:r,server:c})}function E(e,t,r){let{debug:s}=t,{db:a,port:d,server:P}=r||{};return s&&console.debug(`[${e}] server started on port ${d}`),{...i,close:async()=>{let c=[];try{await P?.stop(),s&&console.debug(`[${e}] server stopped on port ${d}`)}catch(n){console.error(`[${e}] server stop error`,n),c.push(n)}if(e==="database")try{await a?.syncToFs(),s&&console.debug(`[${e}] synced to filesystem`)}catch(n){console.error(`[${e}] sync error`,n),c.push(n)}try{await a?.close(),s&&console.debug(`[${e}] closed`)}catch(n){console.error(`[${e}] close error`,n),c.push(n)}if(c.length>0)throw new AggregateError(c,`Failed to close ${e} properly`)},connectionString:B(d,R),dump:async c=>{e==="shadow_database"||!a||await j({db:a,debug:s,destinationPath:c})},port:d,prismaORMConnectionString:B(d,J),terminalCommand:`PGPASSWORD=${i.password} PGSSLMODE=${i.sslMode} psql -h localhost -p ${d} -U ${i.username} -d ${i.database}`}}function B(e,t){return`${X}:${e}/${i.database}?${t.toString()}`}async function L(e,t){let{PGlite:r}=await import("@electric-sql/pglite");return await r.create({database:i.database,dataDir:e,debug:t?5:void 0,relaxedDurability:!1,username:i.username})}async function Q(e,t){let{PGlite:r}=await import("@electric-sql/pglite");return await r.create({database:i.database,dataDir:"memory://",debug:t?5:void 0,relaxedDurability:!1,username:i.username})}async function j(e){let{dataDir:t,db:r,debug:s,destinationPath:a}=e,d=r||await L(t,s),{pgDump:P}=await import("@electric-sql/pglite-tools/pg_dump"),c=await P({args:["--schema-only","--no-owner"],fileName:a?(0,k.filename)(a):void 0,pg:await d.clone()});return a?(s&&console.debug(`[DB] Dumping database to ${a}`),await A(c,a)):(s&&console.debug("[DB] Dumping database to memory"),await c.text())}0&&(module.exports={dumpDB,startDBServer});
