"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateExternalBlocks = exports.validateIgnoredBlocks = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const ast_1 = require("./ast");
const constants_1 = require("./constants");
const validateIgnoredBlocks = (schema, diagnostics) => {
    schema.linesAsArray().map(({ document, lineIndex, text }) => {
        if (text.includes('@@ignore')) {
            const block = (0, ast_1.getBlockAtPosition)(document.uri, lineIndex, schema);
            if (block) {
                diagnostics.add(document.uri, {
                    range: { start: block.range.start, end: block.range.end },
                    message: '@@ignore: When using Prisma Migrate, this model will be kept in sync with the database schema, however, it will not be exposed in Prisma Client.',
                    tags: [vscode_languageserver_1.DiagnosticTag.Unnecessary],
                    severity: vscode_languageserver_1.DiagnosticSeverity.Hint,
                    code: '@@ignore documentation',
                    codeDescription: {
                        href: 'https://pris.ly/d/schema-reference#ignore-1',
                    },
                });
            }
        }
        else if (text.includes('@ignore')) {
            diagnostics.add(document.uri, {
                range: {
                    start: { line: lineIndex, character: 0 },
                    end: { line: lineIndex, character: constants_1.MAX_SAFE_VALUE_i32 },
                },
                message: '@ignore: When using Prisma Migrate, this field will be kept in sync with the database schema, however, it will not be exposed in Prisma Client.',
                tags: [vscode_languageserver_1.DiagnosticTag.Unnecessary],
                severity: vscode_languageserver_1.DiagnosticSeverity.Hint,
                code: '@ignore documentation',
                codeDescription: {
                    href: 'https://pris.ly/d/schema-reference#ignore',
                },
            });
        }
    });
};
exports.validateIgnoredBlocks = validateIgnoredBlocks;
const validateExternalBlocks = (schema, diagnostics) => {
    const externalTables = new Set(schema.config?.tables?.external);
    const externalEnums = new Set(schema.config?.enums?.external);
    for (const block of (0, ast_1.getBlocks)(schema)) {
        if (block.type === 'model' || block.type === 'enum') {
            const blockStartOffset = block.definingDocument.textDocument.offsetAt(block.range.start);
            const blockEndOffset = block.definingDocument.textDocument.offsetAt(block.range.end);
            const [, mapped] = block.definingDocument.content
                .slice(blockStartOffset, blockEndOffset)
                .match(/^\s*@@map\s*\(\s*['"]([^'"]+)['"]\s*\)/m) ?? [];
            const [, schema] = block.definingDocument.content
                .slice(blockStartOffset, blockEndOffset)
                .match(/^\s*@@schema\s*\(\s*['"]([^'"]+)['"]\s*\)/m) ?? [];
            const name = mapped ? mapped : block.name;
            const needle = schema ? `${schema}.${name}` : name;
            const haystack = block.type === 'model' ? externalTables : externalEnums;
            if (haystack.has(needle)) {
                diagnostics.add(block.definingDocument.uri, {
                    range: block.range,
                    message: `The ${block.type} "${block.name}" is marked as external in the Prisma config file.`,
                    tags: [vscode_languageserver_1.DiagnosticTag.Unnecessary],
                    severity: vscode_languageserver_1.DiagnosticSeverity.Hint,
                });
            }
        }
    }
};
exports.validateExternalBlocks = validateExternalBlocks;
//# sourceMappingURL=validations.js.map